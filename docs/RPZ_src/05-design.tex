\chapter{Конструкторский раздел}

В данном разделе будут приведена схема алгоритма Dual Marching Cubes, описаны используемые структуры данных, оценен объем памяти, необходимый для хранения данных, описана структура разрабатываемого программного обеспечения.

\section{Cхема алгоритма Dual Marching Cubes}

На рисунках \ref{img:rpz_drawings-schema_dualmc}-\ref{img:rpz_drawings-enumerateTriangles_3} представлена схема алгоритма Dual Marching Cubes.

\imgs{rpz_drawings-schema_dualmc}{th}{0.4}{Схема алгоритма Dual Marching Cubes}

На рисунке \ref{img:rpz_drawings-schema_dualmc} видно, что алгоритм разделен на 2 этапа:
\begin{itemize}
    \item 1 этап - построение леса восьмеричных деревьев, характеризующих функцию скалярного поля. 
    \item 2 этап - нахождение всех треугольников, описывающих изоповерхность.
\end{itemize}

\subsection{Построение леса восьмеричных деревьев}

Согласно работе\cite{dmc} построение леса восьмеричных деревьев позволяет оптимизировать последующее построение полигональной модели. В каждом листе дерева определяется точка $(x, y, z)$ характеризующая особенность скалярного поля в объеме ячейки, за которую отвечает данный лист дерева. Для этого используется квадратичная функция ошибки: 
\begin{itemize}
    \item рассматривается регулярная сетка внутри ячейки $P$:
    \begin{equation}
        P = { (x, y, z) | x = x_1 + d_x i & y = y_1 + d_y j & z = z_1 + d_z k },
    \end{equation}
    где $(x_1, y_1, z_1)$ - угол ячейки; $ i, j, k \in \overline{0..N} $; $d_x, d_y, d_z$ - шаг сетки;
    \item в каждой точки $(x_i, y_i, z_i) \in P$ строится тангенсальная плоскость к графику функции в точке $w = f(x, y, z)$, и имеет уравнение:
    \begin{equation}
        T_i(x, y, z) = w
    \end{equation}
    \begin{equation}
        T_i(x, y, z) = \nabla f(x_i, y_i, z_i) \cdot ((x, y, z) - (x_i, y_i, z_i));
    \end{equation}
    \item квадратичная функции ошибки для всех точек имеет вид:
    \begin{equation}
        E(w, x, y, z) = \sum_{i} \frac{(w - T_i(x, y, z))^2}{1 + | \nabla f(x_i, y_i, z_i) |^2}.
        \label{eq:qef}
    \end{equation}
\end{itemize}

Точка, в которой квадратичная ошибка минимальна, аппроксимирует функцию наилучшим образом в данном объеме.

Для поиска минимума функции \ref{eq:qef} воспользуемся методом Якоби для решения системы линейных уравнений, в котором каждое уравнение имеет вид:
\begin{equation}
    \nabla f(x_i, y_i, z_i) \cdot (x, y, z) - w = \nabla f(x_i, y_i, z_i) \cdot (x_i, y_i, z_i)
\end{equation}

Однако использовать такие уравнения не результативно - координаты полученной точки часто находятся вне объема ячейки, поэтому нужно добавить ограничение. Сместим точку отсчета координат для точек $(x_i, y_i, z_i)$ в центр ячейки $m$ и добавим уравнения, которые будут устремлять результат в новое начало координат. Теперь система уравнений выглядит следующим образом:
\begin{align}
\nabla f(x_i, y_i, z_i) \cdot (x, y, z) - w &= \nabla f(x_i, y_i, z_i) \cdot ((x_i, y_i, z_i) - m) + f(x_i, y_i, z_i) \\
c_x x &= 0 \\
c_y y &= 0 \\
c_z z &= 0
\end{align}

\imgs{rpz_drawings-schema_generateForest}{th}{0.4}{Схема первого этапа алгоритма, функции \texttt{generateForеst} построения леса восьмеричных деревьев}

\clearpage

\imgs{rpz_drawings-schema_generateTree_1}{th}{0.4}{Схема функции \texttt{generateTree} построения восьмеричного дерева, характеризующего функцию скалярного поля в параллелепипеде}

\clearpage

\imgs{rpz_drawings-schema_generateTree_2}{th}{0.4}{Продолжение схемы функции \texttt{generateTree} построения восьмеричного дерева. Поиск точки, характеризующей функцию в данном объеме }

\subsection{Нахождение всех треугольников изоповерхности}

На рисунках \ref{img:rpz_drawings-enumerateTriangles_1}-\ref{img:rpz_drawings-enumerateTriangles_3} представлен второй этап алгоритма, суть которого заключается в обходе всех соседних ячеек восьмеричных деревьев и применение к соседям алгоритма Marching Cubes. В статье\cite{dmc} предлагают рекурсивное решение этой задачи на двумерном примере(см. рис. \ref{img:rpz_drawings-enumerates}):
\begin{itemize}
    \item к каждой узлу дерева применяют \texttt{enumerateCell}. Если ячейка является поддеревом, к каждому дочернему узлу функция применяет \texttt{enumerateCell}, к каждым парам применяет \texttt{enumerateEdgeX} или \texttt{enumerateEdgeY} и ко всем узлам применяет \texttt{enumerateVertex};
    \item \texttt{enumerateEdgeX} применяется к паре узлов, имеющих общую сторону по оси Х. Если хотя бы один из узлов является поддеревом, то функция применяет \texttt{enumerateEdgeX} и \texttt{enumerateVertex} ко всем ближайшим к стороне узлам. Аналогично работает \texttt{enumerateEdgeY};
    \item \texttt{enumerateVertex} применяется к четырем узлам, имеющим общую точку. Если хотя бы один из узлов является поддеревом, то применяет ко всем ближайшим к точке \texttt{enumerateVertex}. Если же все узлы являются листьями, применить к вершинам в этих листьях Marching Cubes.
\end{itemize}

\imgs{rpz_drawings-enumerates}{th}{0.4}{Схема рекурсивного обхода соседей, для двумерного варианта. Трехмерный вариант является тривиальными расширением двумерного}

\imgs{rpz_drawings-enumerateTriangles_1}{th}{0.4}{Cхема функции \texttt{enumerateTriangles}}

\imgs{rpz_drawings-enumerateTriangles_2}{th}{0.4}{Продолжение схемы функции \texttt{enumerateTriangles}}

\imgs{rpz_drawings-enumerateTriangles_3}{th}{0.4}{Продолжение схемы функции \texttt{enumerateTriangles}}

\clearpage

\section{Описание используемых структур данных и оценка используемой памяти}

В работе алгоритма используются следующие структуры данных:
\begin{itemize}
    \item трехмерный вектор - 3 действительных числа. Занимает 24 байта;
    \item непрерывная функция - получается путем линейной интерполяции значений в слоях линейной томографии. Занимает $(N, M, K)$ действительных чисел, где $(N, M)$ - размер одного слоя; $K$ - количество слоев. Так же имеет 2 трехмерных вектора описывающих ограничение области определения функции. Занимает $N*M*K*8 + 48$ байт;
    \item треугольник - 3 вершины, описанные трехмерными векторами. Занимает 72 байта памяти;
    \item восьмеричное дерево - древовидная структура, узлами которой может быть или поддерево с 8-ю потомками, или лист с координатами вершины и значением функции в ней. Узел-поддерево занимает 64 байта, лист - 32 байта.
\end{itemize}

% Пусть глубина рекурсивного построения дерева ограничена $D$, а размер сетки $(G_x, G_y, G_z)$, тогда количество максимально используемое алгоритмом дополнительной памяти можно оценить в:
% \begin{equation}
%     N M K \cdot 8 + 48 + G_x G_y G_z (\frac{8^{D-1} - 1}{8 - 1} \cdot 64 + 8^D \cdot (32 + 24 \cdot 5)),
% \end{equation}
% то есть $O(N M K + G_x G_y G_z \cdot 8^D)$.

\section{Структура разрабатываемого программного обеспечения}

На рисунке \ref{img:rpz_drawings-uml} представлена UML диаграмма разрабатываемого программного обеспечения.

\imgs{rpz_drawings-uml}{th}{0.3}{UML диаграмма разрабатываемого программного обеспечения}

\clearpage

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}

В данном разделе были приведена схема алгоритма Dual Marching Cubes, описаны используемые структуры данных, оценен объем памяти, необходимый для хранения данных, приведена UML диаграмма разрабатываемого приложения.

