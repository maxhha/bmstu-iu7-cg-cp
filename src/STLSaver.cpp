#include "STLSaver.h"
#include <algorithm>
#include <fstream>
#include <iostream>

namespace CGCP
{
#pragma pack(push)
#pragma pack(1)
    struct STLHeader
    {
        char comment[80];
        std::uint32_t num_triangles;
    };

    struct STLTriangle
    {
        float normal_x;
        float normal_y;
        float normal_z;
        float x1;
        float y1;
        float z1;
        float x2;
        float y2;
        float z2;
        float x3;
        float y3;
        float z3;
        std::uint16_t dummy;
    };

#pragma pack(pop)

    void STLSaver::threadSave(
        const std::string path,
        const MeshPtr mesh,
        ProgressCallback progress_receiver)
    {
        progress_receiver(Error::OK, false, 0);

        auto total_triangles = mesh->triangles().size();
        std::size_t total_progress = total_triangles + 4;
        std::size_t batch_size = total_progress / 100 + 1;
        std::size_t progress = 0;

        std::ofstream f(path, std::ios::binary);

        if (!f.is_open())
        {
            progress_receiver(Error::WRITE_FILE, false, 0);
            return;
        }

        STLHeader header = {
            "Generated by DualMarchingCubes",
            static_cast<std::uint32_t>(total_triangles),
        };

        f.write(reinterpret_cast<const char *>(&header), sizeof(header));

        if (f)
        {
            progress_receiver(
                Error::OK,
                false,
                (double)(++progress) / total_progress);
        }
        else
        {
            progress_receiver(
                Error::WRITE_FILE,
                true,
                (double)(++progress) / total_progress);
            return;
        }

        STLTriangle t;

        for (std::size_t i = 0; i < mesh->triangles().size(); ++i)
        {
            auto &triangle = mesh->triangles()[i];

            t.x1 = triangle.p1().x();
            t.y1 = triangle.p1().y();
            t.z1 = triangle.p1().z();

            t.x2 = triangle.p2().x();
            t.y2 = triangle.p2().y();
            t.z2 = triangle.p2().z();

            t.x3 = triangle.p3().x();
            t.y3 = triangle.p3().y();
            t.z3 = triangle.p3().z();

            f.write(reinterpret_cast<const char *>(&t), sizeof(STLTriangle));

            ++progress;
            if (progress % batch_size == 0)
            {
                progress_receiver(
                    Error::OK,
                    false,
                    (double)progress / total_progress);
            }
        }

        progress_receiver(
            Error::OK,
            false,
            (double)(++progress) / total_progress);

        f.close();

        progress_receiver(f ? Error::OK : Error::WRITE_FILE, true, 1.0);
    }
} // namespace CGCP
